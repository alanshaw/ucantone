package invocation

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"github.com/alanshaw/ucantone/did"
	"github.com/alanshaw/ucantone/ipld"
	"github.com/alanshaw/ucantone/ipld/codec/dagcbor"
	"github.com/alanshaw/ucantone/ipld/datamodel"
	"github.com/alanshaw/ucantone/ucan"
	cmd "github.com/alanshaw/ucantone/ucan/command"
	"github.com/alanshaw/ucantone/ucan/crypto/signature"
	idm "github.com/alanshaw/ucantone/ucan/invocation/datamodel"
	"github.com/alanshaw/ucantone/ucan/nonce"
	"github.com/alanshaw/ucantone/varsig"
	"github.com/alanshaw/ucantone/varsig/algorithm/ed25519"
	"github.com/alanshaw/ucantone/varsig/common"
	cid "github.com/ipfs/go-cid"
	multihash "github.com/multiformats/go-multihash/core"
)

// UCAN Invocation defines a format for expressing the intention to execute
// delegated UCAN capabilities, and the attested receipts from an execution.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md
type Invocation struct {
	link  cid.Cid
	bytes []byte
	sig   *signature.Signature
	model *idm.EnvelopeModel
	task  *Task
}

// Parameters expected by the command.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#arguments
func (inv *Invocation) Arguments() ipld.Map {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Args.Map
}

// The DID of the intended Executor if different from the Subject.
//
// WARNING: May be nil.
//
// https://github.com/ucan-wg/spec/blob/main/README.md#issuer--audience
func (inv *Invocation) Audience() ucan.Principal {
	if inv.model.SigPayload.TokenPayload1_0_0_rc1.Aud == nil {
		return nil
	}
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Aud
}

// Bytes returns the dag-cbor encoded bytes of this invocation.
func (inv *Invocation) Bytes() []byte {
	return inv.bytes
}

// A provenance claim describing which receipt requested it.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#cause
func (inv *Invocation) Cause() *cid.Cid {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Cause
}

// The command to invoke.
//
// https://github.com/ucan-wg/spec/blob/main/README.md#command
func (inv *Invocation) Command() ucan.Command {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Cmd
}

// The timestamp at which the invocation becomes invalid.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#expiration
func (inv *Invocation) Expiration() *ucan.UTCUnixTimestamp {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Exp
}

// An issuance timestamp.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#issued-at
func (inv *Invocation) IssuedAt() *ucan.UTCUnixTimestamp {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Iat
}

// Issuer DID (sender).
//
// https://github.com/ucan-wg/spec/blob/main/README.md#issuer--audience
func (inv *Invocation) Issuer() ucan.Principal {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Iss
}

// Link returns the IPLD link that corresponds to the encoded bytes of this
// invocation.
func (inv *Invocation) Link() cid.Cid {
	return inv.link
}

// Arbitrary metadata or extensible fields.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#metadata
func (inv *Invocation) Metadata() ipld.Map {
	if inv.model.SigPayload.TokenPayload1_0_0_rc1.Meta == nil {
		return nil
	}
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Meta.Map
}

// The datamodel this invocation is built from.
func (inv *Invocation) Model() *idm.EnvelopeModel {
	return inv.model
}

// A unique, random nonce. It ensures that multiple (non-idempotent) invocations
// are unique. The nonce SHOULD be empty (0x) for Commands that are idempotent
// (such as deterministic Wasm modules or standards-abiding HTTP PUT requests).
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#nonce
func (inv *Invocation) Nonce() ucan.Nonce {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Nonce
}

// The path of authority from the subject to the invoker.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#proofs
func (inv *Invocation) Proofs() []cid.Cid {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Prf
}

// The signature over the payload.
//
// https://github.com/ucan-wg/spec/blob/main/README.md#envelope
func (inv *Invocation) Signature() ucan.Signature {
	return inv.sig
}

// The Subject being invoked.
//
// https://github.com/ucan-wg/spec/blob/main/README.md#subject
func (inv *Invocation) Subject() ucan.Principal {
	return inv.model.SigPayload.TokenPayload1_0_0_rc1.Sub
}

// Task returns the CID of the fields that comprise the task for the invocation.
//
// https://github.com/ucan-wg/invocation/blob/main/README.md#task
func (inv *Invocation) Task() ucan.Task {
	return inv.task
}

func (inv *Invocation) MarshalCBOR(w io.Writer) error {
	_, err := w.Write(inv.Bytes())
	return err
}

func (inv *Invocation) UnmarshalCBOR(r io.Reader) error {
	*inv = Invocation{}
	var w bytes.Buffer
	model := idm.EnvelopeModel{}
	err := model.UnmarshalCBOR(io.TeeReader(r, &w))
	if err != nil {
		return fmt.Errorf("unmarshaling invocation envelope CBOR: %w", err)
	}
	if model.SigPayload.TokenPayload1_0_0_rc1 == nil {
		return errors.New("invalid or unsupported invocation token payload")
	}
	header, err := varsig.Decode(model.SigPayload.Header)
	if err != nil {
		return fmt.Errorf("decoding varsig header: %w", err)
	}
	sig := signature.NewSignature(header, model.Signature)
	task, err := NewTask(
		model.SigPayload.TokenPayload1_0_0_rc1.Sub,
		model.SigPayload.TokenPayload1_0_0_rc1.Cmd,
		model.SigPayload.TokenPayload1_0_0_rc1.Args.Map,
		model.SigPayload.TokenPayload1_0_0_rc1.Nonce,
	)
	if err != nil {
		return fmt.Errorf("creating new task: %w", err)
	}
	root, err := cid.V1Builder{
		Codec:  dagcbor.Code,
		MhType: multihash.SHA2_256,
	}.Sum(w.Bytes())
	if err != nil {
		return fmt.Errorf("hashing invocation bytes: %w", err)
	}
	inv.link = root
	inv.bytes = w.Bytes()
	inv.sig = sig
	inv.model = &model
	inv.task = task
	return nil
}

func (inv *Invocation) MarshalDagJSON(w io.Writer) error {
	return inv.Model().MarshalDagJSON(w)
}

func (inv *Invocation) UnmarshalDagJSON(r io.Reader) error {
	*inv = Invocation{}
	model := idm.EnvelopeModel{}
	err := model.UnmarshalDagJSON(r)
	if err != nil {
		return fmt.Errorf("unmarshaling invocation envelope JSON: %w", err)
	}
	if model.SigPayload.TokenPayload1_0_0_rc1 == nil {
		return errors.New("invalid or unsupported invocation token payload")
	}
	header, err := varsig.Decode(model.SigPayload.Header)
	if err != nil {
		return fmt.Errorf("decoding varsig header: %w", err)
	}
	sig := signature.NewSignature(header, model.Signature)
	task, err := NewTask(
		model.SigPayload.TokenPayload1_0_0_rc1.Sub,
		model.SigPayload.TokenPayload1_0_0_rc1.Cmd,
		model.SigPayload.TokenPayload1_0_0_rc1.Args.Map,
		model.SigPayload.TokenPayload1_0_0_rc1.Nonce,
	)
	if err != nil {
		return fmt.Errorf("creating new task: %w", err)
	}
	// marshal to CBOR so we can calculate canonical CID
	var w bytes.Buffer
	err = model.MarshalCBOR(&w)
	if err != nil {
		return fmt.Errorf("marshaling to CBOR: %w", err)
	}
	root, err := cid.V1Builder{
		Codec:  dagcbor.Code,
		MhType: multihash.SHA2_256,
	}.Sum(w.Bytes())
	if err != nil {
		return fmt.Errorf("hashing invocation bytes: %w", err)
	}
	inv.link = root
	inv.bytes = w.Bytes()
	inv.sig = sig
	inv.model = &model
	inv.task = task
	return nil
}

var _ ucan.Invocation = (*Invocation)(nil)

// Encode invocation to CBOR.
func Encode(inv ucan.Invocation) ([]byte, error) {
	return inv.Bytes(), nil
}

// Decode invocation from CBOR.
func Decode(b []byte) (*Invocation, error) {
	inv := Invocation{}
	err := inv.UnmarshalCBOR(bytes.NewReader(b))
	return &inv, err
}

func Invoke(
	issuer ucan.Signer,
	subject ucan.Subject,
	command ucan.Command,
	arguments ipld.Map,
	options ...Option,
) (*Invocation, error) {
	cfg := invocationConfig{}
	for _, opt := range options {
		opt(&cfg)
	}

	if issuer.SignatureCode() != ed25519.Code {
		return nil, fmt.Errorf("unknown signature code: %d", issuer.SignatureCode())
	}
	h, err := varsig.Encode(common.Ed25519DagCbor)
	if err != nil {
		return nil, fmt.Errorf("encoding varsig header: %w", err)
	}

	cmd, err := cmd.Parse(string(command))
	if err != nil {
		return nil, fmt.Errorf("parsing command: %w", err)
	}

	var meta *datamodel.MapWrapper
	if cfg.meta != nil {
		mw := datamodel.MapWrapper{Map: datamodel.Map(cfg.meta)}
		meta = &mw
	}

	nnc := cfg.nnc
	if nnc == nil {
		if cfg.nonnc {
			nnc = []byte{}
		} else {
			nnc = nonce.Generate(16)
		}
	}

	var exp *ucan.UTCUnixTimestamp
	if !cfg.noexp {
		if cfg.exp == nil {
			in30s := uint64(ucan.Now() + 30)
			exp = &in30s
		} else {
			exp = cfg.exp
		}
	}

	iat := cfg.iat
	if iat == nil {
		now := ucan.Now()
		iat = &now
	}

	tokenPayload := &idm.TokenPayloadModel1_0_0_rc1{
		Iss:   issuer.DID(),
		Sub:   subject.DID(),
		Aud:   cfg.aud,
		Cmd:   cmd,
		Args:  datamodel.MapWrapper{Map: datamodel.Map(arguments)},
		Prf:   cfg.prf,
		Meta:  meta,
		Nonce: nnc,
		Exp:   exp,
		Iat:   iat,
		Cause: cfg.cause,
	}

	sigPayload := idm.SigPayloadModel{
		Header:                h,
		TokenPayload1_0_0_rc1: tokenPayload,
	}

	var sigBuf bytes.Buffer
	err = sigPayload.MarshalCBOR(&sigBuf)
	if err != nil {
		return nil, fmt.Errorf("marshaling signature payload: %w", err)
	}

	sigBytes := issuer.Sign(sigBuf.Bytes())
	sig := signature.NewSignature(common.Ed25519DagCbor, sigBytes)

	model := idm.EnvelopeModel{
		Signature:  sigBytes,
		SigPayload: sigPayload,
	}

	task, err := NewTask(
		tokenPayload.Sub,
		tokenPayload.Cmd,
		arguments,
		tokenPayload.Nonce,
	)
	if err != nil {
		return nil, fmt.Errorf("creating task: %w", err)
	}

	var envBuf bytes.Buffer
	err = model.MarshalCBOR(&envBuf)
	if err != nil {
		return nil, fmt.Errorf("marshaling invocation CBOR: %w", err)
	}
	root, err := cid.V1Builder{
		Codec:  dagcbor.Code,
		MhType: multihash.SHA2_256,
	}.Sum(envBuf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("hashing invocation bytes: %w", err)
	}

	return &Invocation{
		link:  root,
		bytes: envBuf.Bytes(),
		sig:   sig,
		model: &model,
		task:  task,
	}, nil
}

func VerifySignature(inv ucan.Invocation, verifier ucan.Verifier) (bool, error) {
	var sub did.DID
	if inv.Subject() != nil {
		sub = inv.Subject().DID()
	}
	var aud *did.DID
	if inv.Audience() != nil {
		a := inv.Audience().DID()
		aud = &a
	}

	var meta *datamodel.MapWrapper
	if inv.Metadata() != nil {
		mw := datamodel.MapWrapper{Map: datamodel.Map(inv.Metadata())}
		meta = &mw
	}

	tokenPayload := &idm.TokenPayloadModel1_0_0_rc1{
		Iss:   inv.Issuer().DID(),
		Sub:   sub,
		Aud:   aud,
		Cmd:   inv.Command(),
		Args:  datamodel.MapWrapper{Map: datamodel.Map(inv.Arguments())},
		Prf:   inv.Proofs(),
		Meta:  meta,
		Nonce: inv.Nonce(),
		Exp:   inv.Expiration(),
		Iat:   inv.IssuedAt(),
		Cause: inv.Cause(),
	}

	h, err := varsig.Encode(inv.Signature().Header())
	if err != nil {
		return false, fmt.Errorf("encoding varsig header: %w", err)
	}

	sigPayload := idm.SigPayloadModel{
		Header:                h,
		TokenPayload1_0_0_rc1: tokenPayload,
	}

	var sigBuf bytes.Buffer
	err = sigPayload.MarshalCBOR(&sigBuf)
	if err != nil {
		return false, fmt.Errorf("marshaling signature payload: %w", err)
	}

	return inv.Issuer().DID() == verifier.DID() && verifier.Verify(sigBuf.Bytes(), inv.Signature().Bytes()), nil
}
